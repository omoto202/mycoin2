<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mini Crypto Demo</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; margin:20px; max-width:900px;}
    section { border:1px solid #ddd; padding:12px; margin-bottom:12px; border-radius:8px;}
    button{ margin-top:6px;}
    textarea{ width:100%; height:120px;}
    input[type=text], input[type=number]{ width:100%;}
    .status { font-weight:bold; margin-left:8px;}
    pre { max-height:200px; overflow:auto; background:#f7f7f7; padding:8px;}
  </style>
</head>
<body>
  <h1>Mini Crypto Demo</h1>

  <section>
    <h2>鍵管理</h2>
    <div>
      <button id="genKey">鍵ペア生成（ブラウザ）</button>
      <button id="saveKey">ローカルストレージに保存</button>
      <button id="resetKey">ローカル鍵をリセット</button>
      <span id="keyStatus" class="status"></span>
    </div>
    <pre id="pubkeyOut"></pre>
  </section>

  <section>
    <h2>送金</h2>
    <label>受信者の公開鍵（base64 SPKI）</label>
    <input id="sendRecipient" type="text" />
    <label>金額</label>
    <input id="sendAmount" type="number" step="0.01" />
    <button id="sendTx">送金（署名してサーバー送信）</button>
    <div id="sendStatus" class="status"></div>
  </section>

  <section>
    <h2>残高確認</h2>
    <label>公開鍵（base64 SPKI）</label>
    <input id="balancePub" type="text" />
    <button id="checkBalance">ブロックチェーンから計算</button>
    <div id="balanceOut" class="status"></div>
  </section>

  <section>
    <h2>ブロックチェーン</h2>
    <button id="refreshChain">最新チェーンを取得してローカル比較</button>
    <button id="clearLocalData">ローカルのトランザクション & チェーンを削除</button>
    <div id="chainStatus" class="status"></div>
    <pre id="chainOut"></pre>
  </section>

  <section>
    <h2>マイニング</h2>
    <button id="startMine">マイニング開始</button>
    <div id="mineStatus" class="status"></div>
  </section>

  <script>
function bufToBase64(buf){ return btoa(String.fromCharCode(...new Uint8Array(buf))); }
function base64ToBuf(b64){ const s = atob(b64); const arr = new Uint8Array(s.length); for(let i=0;i<s.length;i++) arr[i]=s.charCodeAt(i); return arr.buffer; }
function saveLocal(key, obj){ localStorage.setItem(key, JSON.stringify(obj)); }
function loadLocal(key){ const v = localStorage.getItem(key); return v?JSON.parse(v):null; }

// keys: we store private pkcs8 base64 and public spki base64
let currentKey = loadLocal("mini_keypair") || null;
const keyStatus = document.getElementById("keyStatus");
const pubkeyOut = document.getElementById("pubkeyOut");

function updateKeyUI(){
  currentKey = loadLocal("mini_keypair") || null;
  if(currentKey){
    keyStatus.textContent = "鍵あり";
    pubkeyOut.textContent = currentKey.pub;
  } else {
    keyStatus.textContent = "鍵なし";
    pubkeyOut.textContent = "";
  }
}
updateKeyUI();

// generate keypair
document.getElementById("genKey").onclick = async ()=>{
  const kp = await window.crypto.subtle.generateKey(
    { name: "ECDSA", namedCurve: "P-256" },
    true,
    ["sign","verify"]
  );
  const spki = await window.crypto.subtle.exportKey("spki", kp.publicKey);
  const pkcs8 = await window.crypto.subtle.exportKey("pkcs8", kp.privateKey);
  const pubb64 = bufToBase64(spki);
  const privb64 = bufToBase64(pkcs8);
  currentKey = { pub: pubb64, priv: privb64 };
  // do NOT auto-save unless user clicks save
  keyStatus.textContent = "鍵生成済み（未保存）";
  pubkeyOut.textContent = pubb64;
};

// save to local storage
document.getElementById("saveKey").onclick = ()=>{
  if(!currentKey){ alert("鍵がありません。まず生成してください。"); return; }
  saveLocal("mini_keypair", currentKey);
  updateKeyUI();
};

// reset local key
document.getElementById("resetKey").onclick = ()=>{
  localStorage.removeItem("mini_keypair");
  localStorage.removeItem("mini_chain");
  localStorage.removeItem("mini_pending");
  currentKey = null;
  updateKeyUI();
  alert("ローカル鍵・データを削除しました");
};

// prepare signable message: "sender|recipient|amount"
async function signTransaction(sender_pub_b64, priv_pkcs8_b64, recipient, amount){
  const priv_buf = base64ToBuf(priv_pkcs8_b64);
  const priv = await window.crypto.subtle.importKey("pkcs8", priv_buf, { name:"ECDSA", namedCurve:"P-256" }, false, ["sign"]);
  const msg = new TextEncoder().encode(`${sender_pub_b64}|${recipient}|${amount}`);
  const sig = await window.crypto.subtle.sign({ name:"ECDSA", hash:"SHA-256" }, priv, msg);
  return bufToBase64(sig);
}

// --- transactions UI ---
document.getElementById("sendTx").onclick = async ()=>{
  const recipient = document.getElementById("sendRecipient").value.trim();
  const amount = document.getElementById("sendAmount").value;
  const status = document.getElementById("sendStatus");
  if(!currentKey){ status.textContent = "ローカル鍵がありません"; return; }
  if(!recipient || !amount){ status.textContent = "受信者と金額を入力してください"; return; }
  const signature = await signTransaction(currentKey.pub, currentKey.priv, recipient, amount);
  const tx = { sender: currentKey.pub, recipient, amount: parseFloat(amount), signature };
  // optional: save to local pending txs
  let pending = loadLocal("mini_pending") || [];
  pending.push(tx);
  saveLocal("mini_pending", pending);
  // send to server for verification
  const res = await fetch("/submit_tx", {method:"POST", headers:{"Content-Type":"application/json"}, body:JSON.stringify(tx)});
  const j = await res.json();
  if(j.success){
    status.textContent = "送信成功（サーバー受理）";
  } else {
    status.textContent = "送信失敗: " + (j.error||"unknown");
  }
};

// --- balance check ---
document.getElementById("checkBalance").onclick = async ()=>{
  const pub = document.getElementById("balancePub").value.trim();
  if(!pub){ alert("公開鍵を入れてください"); return; }
  // get chain from server
  const res = await fetch("/chain");
  const j = await res.json();
  const chain = j.chain || [];
  // compute balance locally
  let balance = 0.0;
  for(const b of chain){
    for(const t of b.transactions || []){
      if(t.sender !== "SYSTEM" && t.sender === pub) balance -= parseFloat(t.amount);
      if(t.recipient === pub) balance += parseFloat(t.amount);
    }
  }
  document.getElementById("balanceOut").textContent = "残高: " + balance;
};

// --- chain sync, local storage ---
function saveLocalChain(chain){ saveLocal("mini_chain", chain); }
function loadLocalChain(){ return loadLocal("mini_chain") || null; }
function savePending(p){ saveLocal("mini_pending", p); }
function loadPending(){ return loadLocal("mini_pending") || []; }

async function refreshChainAndCompare(){
  const res = await fetch("/chain");
  const j = await res.json();
  const serverChain = j.chain || [];
  const localChain = loadLocalChain();
  let chainStatus = document.getElementById("chainStatus");
  // if localChain absent, adopt server
  if(!localChain || serverChain.length > localChain.length){
    saveLocalChain(serverChain);
    chainStatus.textContent = "ローカルはサーバーの長いチェーンで更新されました";
  } else if (localChain.length > serverChain.length){
    // push local to server and let server decide
    await fetch("/submit_chain", {method:"POST", headers:{"Content-Type":"application/json"}, body:JSON.stringify({chain: localChain})});
    chainStatus.textContent = "ローカルのチェーンをサーバーに提出しました（長ければ置換）";
  } else {
    chainStatus.textContent = "チェーンは同長です。差異があればローカルを優先している可能性あり";
  }
  document.getElementById("chainOut").textContent = JSON.stringify(loadLocalChain()||serverChain, null, 2);
}

document.getElementById("refreshChain").onclick = ()=> refreshChainAndCompare();

document.getElementById("clearLocalData").onclick = ()=>{
  localStorage.removeItem("mini_chain");
  localStorage.removeItem("mini_pending");
  alert("ローカルのトランザクションとチェーンを削除しました");
};

// --- mining ---
document.getElementById("startMine").onclick = async ()=>{
  const status = document.getElementById("mineStatus");
  if(!currentKey) { status.textContent = "ローカル鍵が必要です"; return; }
  status.textContent = "マイニング中";
  // tell server to mine for our pub key
  const res = await fetch("/mine", {method:"POST", headers:{"Content-Type":"application/json"}, body:JSON.stringify({miner_pub: currentKey.pub})});
  const j = await res.json();
  if(j.success){
    status.textContent = "マイニング成功";
    // update local chain to server version
    const chainRes = await fetch("/chain");
    const chainJson = await chainRes.json();
    saveLocalChain(chainJson.chain || []);
    savePending([]); // pending cleared likely
    document.getElementById("chainOut").textContent = JSON.stringify(loadLocalChain(), null, 2);
  } else {
    status.textContent = "マイニング失敗: " + (j.error||"unknown");
  }
};

// --- realtime WebSocket to get broadcasts ---
let ws = null;
function connectWS(){
  try {
    ws = new WebSocket((location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws");
    ws.onopen = ()=> console.log("ws open");
    ws.onmessage = (ev)=>{
      try{
        const d = JSON.parse(ev.data);
        if(d.type === "chain_update"){
          const serverChain = d.chain;
          const localChain = loadLocalChain();
          // if server chain longer -> adopt
          if(!localChain || serverChain.length > localChain.length){
            saveLocalChain(serverChain);
            document.getElementById("chainStatus").textContent = "WSで新しいチェーンを受信してローカル更新";
            document.getElementById("chainOut").textContent = JSON.stringify(serverChain, null, 2);
          } else if (localChain.length > serverChain.length){
            // optionally push local chain back
            fetch("/submit_chain", {method:"POST", headers:{"Content-Type":"application/json"}, body:JSON.stringify({chain: localChain})});
            document.getElementById("chainStatus").textContent = "WSでチェーン通知受信。ローカルが長いのでサーバーに提出";
          }
        }
      }catch(e){}
    };
    ws.onclose = ()=> { console.log("ws closed, retrying in 1s"); setTimeout(connectWS, 1000); };
    ws.onerror = ()=> { ws.close(); };
  } catch(e){
    console.error("ws err", e);
  }
}
connectWS();

// on load, show chain if present
document.addEventListener("DOMContentLoaded", async ()=>{
  const localChain = loadLocalChain();
  if(localChain){
    document.getElementById("chainOut").textContent = JSON.stringify(localChain, null, 2);
  } else {
    const r = await fetch("/chain");
    const j = await r.json();
    saveLocalChain(j.chain || []);
    document.getElementById("chainOut").textContent = JSON.stringify(j.chain || [], null, 2);
  }
});  
  </script>
</body>
</html>
